//go:build ignore
// +build ignore

package main

import (
	"encoding/json"
	"fmt"
	"log"
	"os"
	"sort"
	"strings"
)

// Structures to parse ytInitialData JSON
type YTInitialData struct {
	ContinuationContents struct {
		LiveChatContinuation struct {
			Emojis []EmojiData `json:"emojis"`
		} `json:"liveChatContinuation"`
	} `json:"continuationContents"`
}

type EmojiData struct {
	EmojiID       string    `json:"emojiId"`
	Shortcuts     []string  `json:"shortcuts"`
	SearchTerms   []string  `json:"searchTerms"`
	Image         ImageData `json:"image"`
	IsCustomEmoji bool      `json:"isCustomEmoji"`
}

type ImageData struct {
	Thumbnails []ThumbnailData `json:"thumbnails"`
}

type ThumbnailData struct {
	URL    string `json:"url"`
	Width  int    `json:"width"`
	Height int    `json:"height"`
}

func main() {
	if len(os.Args) < 2 {
		log.Fatal("Usage: go run youtube_emojis_from_ytInitialData.go <youtube_initial_data2.txt>")
	}

	inputFile := os.Args[1]
	outputFile := "youtube_emojis.go"

	// Read the input file
	data, err := os.ReadFile(inputFile)
	if err != nil {
		log.Fatalf("Failed to read input file: %v", err)
	}

	// Remove the "window["ytInitialData"] = " prefix and trailing semicolon if present
	dataStr := string(data)
	if strings.HasPrefix(dataStr, "window[\"ytInitialData\"] = ") {
		dataStr = strings.TrimPrefix(dataStr, "window[\"ytInitialData\"] = ")
	}
	// Remove trailing semicolon and whitespace
	dataStr = strings.TrimRight(dataStr, "; \t\n\r")
	data = []byte(dataStr)

	// Parse JSON
	var ytData YTInitialData
	if err := json.Unmarshal(data, &ytData); err != nil {
		log.Fatalf("Failed to parse JSON: %v", err)
	}

	// Extract custom emojis
	emojiMap := make(map[string]string)

	emojis := ytData.ContinuationContents.LiveChatContinuation.Emojis
	for _, emoji := range emojis {
		// Only process custom emojis
		if !emoji.IsCustomEmoji {
			continue
		}

		// Get the highest quality image URL
		imageURL := ""
		maxWidth := 0
		for _, thumb := range emoji.Image.Thumbnails {
			if thumb.Width > maxWidth {
				maxWidth = thumb.Width
				imageURL = thumb.URL
			}
		}

		// Map each shortcut to the image URL
		for _, shortcut := range emoji.Shortcuts {
			if imageURL != "" && shortcut != "" {
				emojiMap[shortcut] = imageURL
			}
		}
	}

	if len(emojiMap) == 0 {
		log.Fatal("No custom emojis found in the input file")
	}

	// Generate the output file
	if err := generateGoFile(outputFile, emojiMap); err != nil {
		log.Fatalf("Failed to generate output file: %v", err)
	}

	fmt.Printf("Successfully generated %s with %d emoji mappings\n", outputFile, len(emojiMap))
}

func generateGoFile(filename string, emojiMap map[string]string) error {
	f, err := os.Create(filename)
	if err != nil {
		return err
	}
	defer f.Close()

	// Write header
	fmt.Fprintln(f, "// Code generated by youtube_emojis_from_ytInitialData.go; DO NOT EDIT.")
	fmt.Fprintln(f, "// To regenerate, run: go run youtube_emojis_from_ytInitialData.go youtube_initial_data2.txt")
	fmt.Fprintln(f, "")
	fmt.Fprintln(f, "package main")
	fmt.Fprintln(f, "")
	fmt.Fprintln(f, "// ytEmojiShortcutToHTML maps YouTube custom emoji shortcuts to their image URLs")
	fmt.Fprintln(f, "var ytEmojiShortcutToHTML = map[string]string{")

	// Sort keys for consistent output
	shortcuts := make([]string, 0, len(emojiMap))
	for shortcut := range emojiMap {
		shortcuts = append(shortcuts, shortcut)
	}
	sort.Strings(shortcuts)

	// Write map entries
	for _, shortcut := range shortcuts {
		url := emojiMap[shortcut]
		// Create an <img> tag for the emoji
		imgTag := fmt.Sprintf(`<img src="%s" alt="%s" class="emoji">`, url, shortcut)
		fmt.Fprintf(f, "\t%q: %q,\n", shortcut, imgTag)
	}

	fmt.Fprintln(f, "}")

	return nil
}
